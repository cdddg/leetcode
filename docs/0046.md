# [46. Permutations](https://leetcode.com/problems/permutations)

Given an array `nums` of distinct integers, return _all the possible permutations_. You can return the answer in **any order**.

**Example 1:**

    Input: nums = [1,2,3]
    Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

**Example 2:**

    Input: nums = [0,1]
    Output: [[0,1],[1,0]]

**Example 3:**

    Input: nums = [1]
    Output: [[1]]

**Constraints:**

* `1 <= nums.length <= 6`
* `-10 <= nums[i] <= 10`
* All the integers of `nums` are **unique**.

**Related Topics:** `array` `backtracking`

<br>

## Solutions [^2]:

- [**Why O(N\*N!) and not just O(N!) ?**](https://leetcode.com/problems/permutations/discuss/993970/Python-4-Approaches-%3A-Visuals-%2B-Time-Complexity-Analysis)
  Many people are debating in the solution tab whether time-complexity should be `O(N!)` or `O(N * N!)`. Below are two intuitive arguments as to why it should be `O(N*N!)`. Let's forget for a while about the recursive nature of the algorithm and examine the **N-ary, recursive, space-tree** that is generated by the recursive algorithm.
  <br>

![image](https://assets.leetcode.com/users/images/ac9c35dc-89b8-4860-b08c-d2f60859e43e_1609289801.6830964.png)

<br>

`recursive`

Time complextity: O(`N*N!`) <br>
Space complexity: O(`n!`)

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.recursive(nums, [], res)
        
        return res
    
    def recursive(self, nums: List[int], path: List[int], res: List[List[int]]):        
        for i, n in enumerate(nums):
            #      1  1  2
            #         i
            #    [:i]   [i+1]
            self.recursive(nums[:i] + nums[i+1:], path+[n], res)
        if not nums:
            res.append(path)
```

<br>

`iterative`

Time complextity: O(`N*N!`) <br>
Space complexity: O(`n!`)

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        return self.iterative(nums)
    
    def iterative(self, nums):
        stack = [(nums, [])]   # nums, path (or perms)
        res = []
        while stack:
            nums, path = stack.pop()
            for i, n in enumerate(nums):
                #      1  1  2
                #         i
                #    [:i]   [i+1]
                stack.append((nums[:i] + nums[i+1:], path+[n]))
            if not nums:
                res.append(path)

        return res
```

<br>

`built-in`

```python
import itertools

class Solution:
    def permute(self, nums):
        return list(itertools.permutations(nums))
```

<br>

[^1]: `2021/09/02`
[^2]: `2022/04/04`

